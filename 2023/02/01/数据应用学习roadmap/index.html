<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Roadmap to becoming an Artificial Intelligence Expert in 2022 | Ducky's Blog</title><meta name="author" content="Ducky"><meta name="copyright" content="Ducky"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言：对于一门复杂且快速迭代的学科，掌握知识的结构比掌握知识本身更重要，相信很多对数据科学和人工智能有兴趣的朋友一开始总免不了主动或被动的翻看各种大部头的技术书籍。由于技术书籍本身非常微观具体和颇有难度，self-learner往往容易深陷在某几个章节，要么难以持续，要么进展缓慢；倘若一开始，可以顺着一个全局的路线图来学习，本着循序渐进和有的放矢的节奏，那对于人工智能的学习理解会更加高效；  A">
<meta property="og:type" content="article">
<meta property="og:title" content="Roadmap to becoming an Artificial Intelligence Expert in 2022">
<meta property="og:url" content="https://duckywang.github.io/2023/02/01/%E6%95%B0%E6%8D%AE%E5%BA%94%E7%94%A8%E5%AD%A6%E4%B9%A0roadmap/index.html">
<meta property="og:site_name" content="Ducky&#39;s Blog">
<meta property="og:description" content="前言：对于一门复杂且快速迭代的学科，掌握知识的结构比掌握知识本身更重要，相信很多对数据科学和人工智能有兴趣的朋友一开始总免不了主动或被动的翻看各种大部头的技术书籍。由于技术书籍本身非常微观具体和颇有难度，self-learner往往容易深陷在某几个章节，要么难以持续，要么进展缓慢；倘若一开始，可以顺着一个全局的路线图来学习，本着循序渐进和有的放矢的节奏，那对于人工智能的学习理解会更加高效；  A">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/duckywang/picgo/img/202304111339462.png">
<meta property="article:published_time" content="2023-01-31T16:00:00.000Z">
<meta property="article:modified_time" content="2024-01-21T08:03:48.587Z">
<meta property="article:author" content="Ducky">
<meta property="article:tag" content="数据">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/duckywang/picgo/img/202304111339462.png"><link rel="shortcut icon" href="/./img/infinite.png"><link rel="canonical" href="https://duckywang.github.io/2023/02/01/%E6%95%B0%E6%8D%AE%E5%BA%94%E7%94%A8%E5%AD%A6%E4%B9%A0roadmap/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":20},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Ducky","link":"链接: ","source":"来源: Ducky's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Roadmap to becoming an Artificial Intelligence Expert in 2022',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-21 16:03:48'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='blog-folder\source\img\wallhaven-404!.jpeg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> Others</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/duckywang/picgo/img/202304111339462.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Ducky's Blog"><span class="site-name">Ducky's Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> Others</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Roadmap to becoming an Artificial Intelligence Expert in 2022</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-31T16:00:00.000Z" title="发表于 2023-02-01 00:00:00">2023-02-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-21T08:03:48.587Z" title="更新于 2024-01-21 16:03:48">2024-01-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%85%B7%E4%BD%93%E7%9A%84/">具体的</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Roadmap to becoming an Artificial Intelligence Expert in 2022"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>前言：对于一门复杂且快速迭代的学科，掌握知识的结构比掌握知识本身更重要，相信很多对数据科学和人工智能有兴趣的朋友一开始总免不了主动或被动的翻看各种大部头的技术书籍。由于技术书籍本身非常微观具体和颇有难度，self-learner往往容易深陷在某几个章节，要么难以持续，要么进展缓慢；倘若一开始，可以顺着一个全局的路线图来学习，本着循序渐进和有的放矢的节奏，那对于人工智能的学习理解会更加高效；</p>
</blockquote>
<p>AMAI GmbH是一家位于德国的软件公司，最近在GitHub上发布了一个名为“AI-Expert-Roadmap”的项目。该项目提供了全面的AI领域知识点，几乎涵盖了AI领域所有的内容。如果你想快速入门并成为AI领域的专家，这个路线图可能会给你带来指引。该项目上线短短几天就获得了2.1k颗星的好评。</p>
<p>本系列的文章将简要地叙述这个学习路线框架，由于篇幅较长建议参考右侧栏目录查看，如果感兴趣可以浏览学习<strong>项目地址</strong>：<a target="_blank" rel="noopener" href="https://github.com/AMAI-GmbH/AI-Expert-Roadmap/">https://github.com/AMAI-GmbH/AI…</a></p>
<h2 id="导言">导言</h2>
<p>这里并非需要严格按照路线图前进，但是需要清楚某个知识在整个框架中的哪一环节，具体对你关心的部分的影响权重如何，是否依赖其他部分的知识；清楚了这个优先级的背景知识，可以帮助我们在自学过程中减少很多焦虑或迷茫~！<br>
<img src="https://github.com/duckywang/picgo/blob/main/img/202304102301782.png?raw=true" alt="要循序渐进，而非直接到深度学习"></p>
<h2 id="Foundamentals">Foundamentals</h2>
<h3 id="矩阵和线性代数基础">矩阵和线性代数基础</h3>
<p>在数据科学和AI领域所接触到的数据和平时我们熟悉的数据最大的区别，就是维度化和向量化，这是因为我们通常需要输入或让机器学习比较复杂的数据结构，这种结构通常就是用向量矩阵来表示的；而对于这种数据类型的计算规则就需要用到线性代数的基础知识；由于课本的线性代数知识比较复杂，建议先了解基础知识，等遇到了具体的问题再具体深入学习对应的工具；<br>
必须掌握的基础知识：</p>
<p>线性代数本质：图像或更高维数据的线性变化，可以总结为在几向量方向的拉伸、旋转；<br>
矩阵的运算：点积</p>
<h3 id="数据库基础">数据库基础</h3>
<h4 id="关系型和非关系型数据："><a target="_blank" rel="noopener" href="https://www.dataversity.net/review-pros-cons-different-databases-relational-versus-non-relational/">关系型和非关系型数据</a>：</h4>
<p>关系数据库就像是一个大型的电子表格，数据存储在由行和列组成的表中，并且需要预定义表的结构和关系。(RDBMS：Relational Database Management Systems)也就是我们常说的SQL database；而非关系型数据库则更像是一个散列表或字典，它们不需要预定义固定的表结构，可以根据需要动态添加新的字段和属性。这种数据库通常适用于半结构化或非结构化数据，例如JSON或XML格式的数据。<br>
再举一个例子，关系型数据库就像一家传统的银行，每个客户都有自己的帐户，所有交易记录都按照特定的格式进行记录，并且需要遵守特定的规则和标准。而非关系型数据库就像一个市场摊位，各个商贩可以自由地展示和出售自己的产品，每个商贩也可以随时添加和修改自己的货品和价格。虽然市场摊位没有像银行那么严谨的规定和要求，但它具有更高的灵活性和适应性，能够更好地满足不同的需求。</p>
<h4 id="基础的SQL语法">基础的SQL语法</h4>
<p>如何查询所谓的关系型数据库呢，我们可以通过数据库查询语言进行；<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Join_(SQL)">SQL</a>（Structured Query Language）是一种用于管理关系型数据库的标准化语言。它可以用来创建、查询、更新和删除数据库中的数据。SQL使用简单易懂的语法，允许我们通过输入各种命令来与数据库交互，比如SELECT、INSERT、UPDATE和DELETE等命令。</p>
<p>可以把SQL想象成一个非常强大的工具箱，里面有各种各样的工具，帮助我们对数据库进行操作。举个例子，如果我们想要从一个表中检索某些数据，我们可以使用SELECT命令。如果我们想要在表中插入新的数据，我们可以使用INSERT命令。如果我们想要更新表中的数据，我们可以使用UPDATE命令。如果我们想要删除数据，我们可以使用DELETE命令。</p>
<p>总之，SQL是一种重要的编程语言，它为开发人员提供了一种可靠的方式来管理和操纵数据库中的数据。</p>
<h4 id="NoSQL">NoSQL</h4>
<p>常见的NOSQL数据库有以下几种：<br>
-文档型数据库：MongoDB、Couchbase、RavenDB等。<br>
-列族数据库：HBase、Cassandra、Scylla等。<br>
-键值对数据库：Redis、Memcached、Couchbase等。<br>
-图形数据库：Neo4j、OrientDB、Titan等。<br>
-对象数据库：db4o、Versant Object Database等。<br>
这些不同类型的NOSQL数据库适用于各种不同的应用场景和需求。例如，文档型数据库通常用于存储半结构化数据，列族数据库通常用于大规模分布式系统，键值对数据库通常用于缓存和快速查找，图形数据库通常用于复杂的网络关系图分析，而对象数据库则更适合面向对象的开发模型。</p>
<p>和SQL语法的关系：<br>
-查询语言：SQL使用结构化查询语言（Structured Query Language）作为查询语言，而NOSQL数据库则根据其特定的数据模型和用途，使用不同的查询语言或API。例如，MongoDB使用MongoDB查询语言（MQL），Cassandra使用CQL（Cassandra Query Language）等等。</p>
<p>-数据操作：SQL使用标准的INSERT、SELECT、UPDATE和DELETE等命令进行数据操作，而NOSQL数据库则根据其特定的数据模型和查询语言，提供不同的数据操作方式。例如，MongoDB提供了find、insert、update、remove等方法，Redis则提供了get、set、del等命令。</p>
<p>-索引：SQL数据库通常使用B-tree索引，而NOSQL数据库则根据其特定的数据结构和查询方式，使用不同的索引类型。例如，MongoDB使用B-tree和哈希索引，Cassandra使用SSTable索引等等。</p>
<h3 id="表格数据：">表格数据：</h3>
<p>是指按照表格形式组织的数据，其中每一行表示一个记录或实例，每一列表示一个属性或特征，每个记录都有相同的数据结构。因此，表格数据可以用于存储、查询和分析非常规则化的数据集，例如订单信息、客户信息、销售报表等等。表格数据是在计算机科学和数据处理领域中最基本和最常用的类型之一，它们既易于理解又容易处理。许多数据分析工具和技术都是针对表格数据而设计的，例如SQL查询、数据透视表、图表等等。</p>
<h3 id="DataFrame-Series">DataFrame &amp; Series</h3>
<p>Data Frames和Series是Pandas库中常用的两种非常重要的数据结构。Pandas是一个开源的Python数据处理库，它提供了丰富、高效的数据分析工具，特别适合用于表格型或异质型数据的处理。</p>
<p><strong>DataFrame</strong>：DataFrame是一种二维表格型数据结构，类似于Excel表格或SQL数据库中的表。每个DataFrame对象都由行和列组成，其中每一列可以是不同的数据类型（例如整数、浮点数、字符串等等）。我们可以将DataFrame看作是由多个Series对象组成的字典，它们共享相同的行索引，但拥有不同的列索引。在Pandas中，DataFrame通常被用来存储和处理大量的结构化数据，例如时间序列数据、金融数据、人口统计数据等等。</p>
<p><strong>Series</strong>：Series是一种一维数组型数据结构，类似于Python中的列表（list）或Numpy中的一维数组（ndarray）。每个Series对象都由一组数据和一组与之对应的索引组成，它们可以是数字、字符串、布尔值等等。Series可以看作是DataFrame中的一列数据，也可以单独使用，通常用于存储和处理一些简单的数据集合，例如某个特定时期内的温度数据、股票价格变动数据等等。</p>
<h3 id="数据预加工ETL">数据预加工ETL</h3>
<p>ETL(Extract,Transform,Load)是指从数据源中抽取（Extract）数据，经过转换（Transform）处理，最后加载（Load）到目标库中的一种数据集成方法。ETL通常用于将多个数据源中的数据进行汇聚、清洗、整合和转换，以便更好地支持数据分析、业务决策和数据挖掘等应用。</p>
<p>用一个比较形象的例子来介绍ETL的过程：假设你正在收集各个城市的天气信息，你需要将不同城市的气温、湿度、降雨量等数据抽取出来，并进行转换和整合，最后汇总到一个数据库中供数据分析专家使用。</p>
<p>-首先，你需要从各个数据源中抽取数据，例如从气象局网站上爬取每个城市的气象数据。这个过程就是Extract。</p>
<p>-接下来，你需要对采集到的数据进行转换，例如将不同城市的数据统一格式化，清洗掉不合法或重复的数据，计算平均温度等等。这个过程就是Transform。</p>
<p>-最后，你需要将处理后的数据加载到目标数据库中，例如使用SQL语句将数据插入到一个关系型数据库中，或者使用Hadoop/Hive将数据加载到一个大数据存储中。这个过程就是Load。</p>
<p>通过ETL的过程，你可以将来自不同数据源的数据进行整合和处理，得到更加规范化、一致性和可靠性的数据集合。这些数据可以用于数据分析、机器学习、业务报表等各种应用场景，帮助你做出更准确、更有针对性的决策。</p>
<h3 id="Reporting-BI-Analytics">Reporting &amp; BI &amp; Analytics</h3>
<p>Reporting、BI和Analytics是数据分析领域中的三个重要概念，都是数据分析领域中的重要概念。报表主要用于展示数据或信息，BI则注重企业数据的转换和利用，Analytics则专注于数据分析和挖掘，发现新的洞见和知识。这些概念在实际应用中有着各自不同的侧重点和目标，但却都能为企业提供更多的商业价值，它们之间有些微妙的不同点：-</p>
<p>-<strong>Reporting（报表）</strong>：Reporting通常是指展示数据或信息的静态或半静态的格式化文档。这些文档可以是PDF、Excel、Word等各种格式，通常用于告诉人们<strong>什么已经发生、正在发生或可能会发生</strong>。报表往往会根据用户需求生成预定的格式，并在固定时间内自动更新，例如月度财务报告、销售报告、客户报告等等。</p>
<p>-<strong>BI（商业智能）</strong>：BI是指通过数据挖掘、数据分析、数据可视化和其他技术手段，将企业数据转换为有价值的信息和洞见。BI旨在帮助企业做出更明智的决策，优化业务流程和提高效率。与报表不同的是，BI通常会涉及对历史数据和趋势的分析以及对未来情景的模拟和预测，同时也可以使用交互性的可视化工具，让用户能够更好地理解数据和信息。</p>
<p>-<strong>Analytics（分析）</strong>：Analytics通常被看作是BI的一部分，它着重于数据分析和挖掘，通过使用各种技术和工具对数据进行挖掘和解释，以发现新的信息和知识。Analytics可以帮助企业发现隐藏的模式、关联和趋势，进而提供更具体、更深入的见解，从中获得更好的商业价值。</p>
<h3 id="Data-Formats-常见的数据交换格式">Data Formats 常见的数据交换格式</h3>
<p>数据交换格式是指用于在不同系统之间传输和共享数据的一种标准化格式。数据交换格式通常包括了数据结构、编码规则和交换协议等多个方面，其目的是为了保证不同系统之间能够正确地解析和使用数据。<br>
在实际应用中，不同的系统可能会使用不同的数据格式来存储和处理数据，这就对数据的交换和共享带来了一些困难。为了解决这个问题，人们设计出了一系列标准化的数据交换格式，例如JSON、XML、CSV、Protobuf、Avro等等。这些数据交换格式具有以下特点：</p>
<h4 id="JSON">JSON</h4>
<p>JSON（JavaScript Object Notation）：JSON是一种轻量级的数据交换格式，通常用于Web应用程序中的数据传输。JSON采用基于键值对的方式存储数据，支持多层嵌套结构，可以表示复杂的数据结构。它的语法简洁明了，易于阅读和编写，并且能够被大部分编程语言解析和生成。因此，在互联网领域，JSON已经成为了最流行的数据格式之一。</p>
<h4 id="XML">XML</h4>
<p>XML（Extensible Markup Language）：XML也是一种用于数据交换的标记语言，它支持自定义标签和属性，可以表示非常复杂的数据结构。XML在Web服务、文档传输、配置文件等方面非常常见，但由于其标签比较冗长，语法相对复杂，因此在数据传输方面逐渐被JSON所取代。</p>
<h4 id="CSV">CSV</h4>
<p>CSV（Comma-Separated Values）：CSV是一种简单的纯文本文件格式，它使用逗号或其他分隔符将数据字段分隔开，每行表示一个记录或实例。CSV最初是电子表格软件中的一种常用数据格式，但现在已经广泛应用于数据交换和数据处理领域。CSV的优点是语法简单，易于生成和解析，并且可以作为多个数据分析工具之间的通用格式进行数据转换。</p>
<h3 id="正则表达式RegExp">正则表达式RegExp</h3>
<p>（Regular Expression），简称为Regex或RegExp，是一种用于字符串匹配和文本处理的表达式语言。它是通过定义规则来匹配和处理字符串的一种方式，可以在不知道具体字符串内容的情况下，快速地检索、替换和提取字符串。<br>
正则表达式通常由各种字符和特殊符号组成，这些符号代表着某些意义或规则。例如，使用字符集合[]来表示一个字符集合，使用量词符{}来表示匹配次数，使用锚点^和$来表示字符串的开头和结尾等等。正则表达式的规则非常灵活，可以根据需要自由组合和扩展，以满足不同的字符串匹配和文本处理需求。可以了解比较基础的正则语法，具体的语法也是可以等到使用时再进行学习和查询；<br>
<img src="https://cdn.jsdelivr.net/gh/duckywang/picgo/img/202304102323252.png" alt="数据，一切的基础"></p>
<h3 id="Python-Programming">Python Programming</h3>
<h4 id="Python-基础">Python 基础</h4>
<h5 id="Python表达式">Python表达式</h5>
<p>Expressions是Python程序中的一种基本元素，它们由变量、操作符和函数组成，用于计算并返回一个值。Python表达式可以用于各种场合，例如赋值语句、条件语句、循环语句和函数调用等。Python表达式通常由以下几个部分组成：</p>
<p>-变量：变量是Python程序中的一个标识符，用于存储和处理数据。在表达式中，我们可以使用变量来表示一个值或对象。</p>
<p>-操作符：操作符是用于进行数学运算、比较和逻辑判断的符号。常见的操作符包括加号+、减号-、乘号*、除号/、等于号=、大于号&gt;等等。</p>
<p>-函数：函数是一段可重复使用的代码块，用于封装和执行特定的任务。在表达式中，我们可以使用内置函数或自定义函数来执行特定的计算和操作。<br>
例如，下面是一个简单的Python表达式，在这个表达式中，变量x和y分别被赋值为10和5，z被计算为(x+y)*2的结果，最终输出z的值20：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line">y = <span class="number">5</span></span><br><span class="line">z = (x + y) * <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(z)</span><br></pre></td></tr></table></figure>
<h5 id="变量">变量</h5>
<p>Python中的变量（Variables）是用于存储数据值的标识符，可以通过变量名来访问和操作对应的数据。在Python中，变量不需要显式地声明，而是在第一次赋值时自动创建，并且可以随时重新赋值。</p>
<p>以下是一些常见的Python变量类型：</p>
<p>-整数：整数类型（int）用于存储整数值，例如：x = 10</p>
<p>-浮点数：浮点数类型（float）用于存储实数值，例如：y = 3.14</p>
<p>-布尔值：布尔类型（bool）用于存储True或False两种值，例如：z = True</p>
<p>-字符串：字符串类型（str）用于存储文本，例如：name = “Bob”</p>
<p>变量名必须遵循一定的命名规则，通常采用小写字母和下划线的组合，例如：my_variable、person_name等。此外，在Python中还有一些约定俗成的命名规则，例如：类名采用驼峰命名法、私有变量前面加上下划线等。</p>
<p>在Python中，变量的类型是动态的（Dynamic Typing），即它们的类型可以随着赋值操作而改变。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = 10      # x是整数类型</span><br><span class="line">x = "hello" # x变成字符串类型</span><br></pre></td></tr></table></figure>
<p>总之，Python中的变量是用于存储数据值的标识符，可以随时重新赋值，并且可以自动推导出其类型。开发者需要遵循命名规则和约定俗成的命名方式(见PEP 8)，以提高代码的可读性和可维护性。</p>
<h5 id="数据格式">数据格式</h5>
<p>Data Structures<br>
Python中的数据结构（Data Structures）是一种用于组织和存储数据的方式，可以支持各种不同类型的数据操作。Python提供了多种内置的数据结构，包括列表、元组、字典、集合等。</p>
<p>以下是一些常见的Python数据结构：</p>
<p>-列表（List）：列表是一种有序的数据结构，可以存储任意数量的元素，并且支持动态添加、删除、修改等操作。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">"hello"</span>, <span class="literal">True</span>]</span><br></pre></td></tr></table></figure>
<p>-元组（Tuple）：元组也是一种有序的数据结构，类似于列表，但是它的元素不可修改。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_tuple = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">"hello"</span>, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>–字典（Dictionary）：字典是一种键值对的数据结构，可以通过键来访问对应的值，支持动态添加、删除、修改等操作。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_dict = {<span class="string">"name"</span>: <span class="string">"Bob"</span>, <span class="string">"age"</span>: <span class="number">25</span>, <span class="string">"gender"</span>: <span class="string">"male"</span>}</span><br></pre></td></tr></table></figure>
<p>-集合（Set）：集合是一种无序的数据结构，可以存储任意数量的元素，并且自动去重。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_set = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>}</span><br></pre></td></tr></table></figure>
<p>除了以上内置的数据结构之外，Python还支持其他一些高级的数据结构，例如堆（Heap）、队列（Queue）等，它们可以在不同的场景下提高代码的效率和可读性。</p>
<p>总之，Python中的数据结构是一种用于组织和存储数据的方式，开发者可以根据具体需求选择适合的数据结构，并且灵活地使用内置方法和操作来对其进行增删改查等操作。</p>
<h5 id="函数">函数</h5>
<p>在Python中，函数（Function）是一种可重用的代码块，可以接受输入参数并返回输出结果。通过定义封装和调用，函数能够提高代码的可读性、可维护性和复用性，常常被用于封装特定功能和算法。<br>
在Python中，函数定义采用关键字def，后面跟着函数名和参数列表，参数列表中的参数可以有默认值，也可以使用带*的元组形式来接收任意数量的位置参数，或者使用带**的字典形式来接收任意数量的关键字参数。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name=<span class="string">"world"</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hello, "</span> + name + <span class="string">"!"</span>)</span><br><span class="line"></span><br><span class="line">greet()         <span class="comment"># 输出"Hello, world!"</span></span><br><span class="line">greet(<span class="string">"Alice"</span>)  <span class="comment"># 输出"Hello, Alice!"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum</span>(<span class="params">*numbers</span>):</span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> numbers:</span><br><span class="line">        total += num</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line">result = <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(result)   <span class="comment"># 输出15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">**kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(kwargs)</span><br><span class="line"></span><br><span class="line">info(name=<span class="string">"Alice"</span>, age=<span class="number">25</span>, gender=<span class="string">"female"</span>)</span><br><span class="line"><span class="comment"># 输出{"name": "Alice", "age": 25, "gender": "female"}</span></span><br></pre></td></tr></table></figure>
<p>Python 主要的内置函数查询</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import builtins</span><br><span class="line"></span><br><span class="line">dir(builtins)</span><br></pre></td></tr></table></figure>
<p><strong>map</strong>：主要联合其他函数使用，将函数依次作用到序列的每个元素，得到一个新的序列。<br>
<strong>filter</strong>：是将传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素，主要对序列的值进行过滤<br>
<strong>sorted</strong>：sorted(iterable,key=None, reverse=False)接受一个key函数来实现对可迭代对象进行自定的排序<br>
<strong>reduce</strong>：指定列表中两两相邻元素的结合条件</p>
<p><strong>迭代器和生成器</strong>：都是 Python 中用来处理集合对象的概念。</p>
<p>-迭代器是Python最强大的功能之一，是访问集合元素的一种方式。 迭代器是所有包含了__iter__() 和__next__() 方法的对象。其中__iter__() 方法返回迭代器对象本身，而__next__() 方法返回集合中的下一个元素。当没有更多元素时，该方法应该引发 StopIteration 异常。通常可以用于遍历可视化图像数据集；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">my_iter = <span class="built_in">iter</span>(my_list)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(my_iter))  <span class="comment"># 输出 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(my_iter))  <span class="comment"># 输出 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(my_iter))  <span class="comment"># 输出 3</span></span><br></pre></td></tr></table></figure>
<p>以下是一些常见的数据结构，也是 Python 内置的迭代器类型：</p>
<p>列表（list）、元组（tuple）和集合（set）等序列类型都支持迭代器协议，因此它们可以被视为迭代器。</p>
<p>字典（dict）类型虽然不是序列，但也支持迭代器协议。当我们对一个字典进行迭代时，实际上是在遍历它的键。</p>
<p>文件（file）类型也实现了迭代器协议，每次迭代会返回文件中的下一行。</p>
<p>-在Python中，使用了yield的函数被称为生成器，生成器则是一种特殊的迭代器，它基于函数生成值序列。在函数内部，使用 yield 语句产生值。每次调用生成器的 next() 方法时，它会执行到 yield 语句处并返回一个值。再次调用 next() 方法时，该函数将从上次离开的地方恢复执行。和其他函数不同的是，每当程序执行完语句时，程序就会暂停执行。<br>
以下是一个简单的生成器示例，生成斐波那契数列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci</span>():</span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用生成器输出前 10 个斐波那契数列</span></span><br><span class="line"><span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(fibonacci()):</span><br><span class="line">    <span class="keyword">if</span> i &gt;= <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure>
<p>生成器会无限地生成斐波那契数列，但在这个例子中我们使用了一个 break 语句来限制输出的数量。每次调用 next() 方法时，该生成器函数都会在 yield 语句处暂停并返回一个值（即当前斐波那契数），直到再次被调用以产生下一个值。</p>
<p>除了以上特性之外，Python函数还支持闭包、装饰器等高级特性，可以实现更加灵活和高效的编程方式。</p>
<h5 id="包管理语言-依赖管理器">包管理语言&amp;依赖管理器</h5>
<p>包管理语言是指一种用于管理特定编程语言或平台的软件包的工具或系统。它们提供了一种简单的方式来安装、升级和删除软件包，并解决软件项目中的依赖关系。在包管理语言中，软件包通常被存储在公共或私有的存储库（如npm、NuGet、PyPI等）中，并且可以通过特定的命令行工具进行访问和管理。这些工具可以下载和安装软件包及其依赖项，同时还可以提供其他功能，例如搜索和列出可用的软件包、创建和发布软件包等。</p>
<p>Dependency manager（依赖管理器）是指一种工具，用于管理软件项目中的依赖关系。在软件开发中，通常需要使用许多不同的库和框架来构建一个功能完整的应用程序，这些库和框架之间可能存在复杂的依赖关系。使用依赖管理器可以自动地解决这些依赖关系，安装和升级所需的包和库，从而简化了开发者的工作流程，提高了项目的可维护性和可重用性。目前比较知名的依赖管理器有npm、pip、Maven等。</p>
<p>包管理器通常包含依赖管理器的功能；</p>
<p>Python 常见的包管理工具有：</p>
<p>pip：Python 的默认包管理器，可以从 PyPI（Python Package Index）上安装、升级和卸载各种 Python 包。</p>
<p>Anaconda：一种针对数据科学领域的 Python 发行版，内置了众多数据分析和科学计算常用的包，可以使用 conda 进行包管理。</p>
<p>easy_install：另一种 Python 包安装工具，与 pip 类似，但已经逐渐被取代。</p>
<p>virtualenv：一种 Python 虚拟环境管理工具，可以创建独立的 Python 环境，使得不同项目之间可以隔离开来并且使用不同版本的 Python 和不同的库。</p>
<h5 id="Codestyle">Codestyle</h5>
<p>Codestyle是指编写代码时所遵守的规范和约定，它包括了代码组织、命名规则、注释风格、缩进方式、代码结构等方面的要求。能够提高代码的可读性、可维护性和可扩展性，从而降低代码出错和重构的风险。<br>
PEP 8：PEP 8是Python语言的官方Codestyle规范，提供了关于代码布局、注释、命名、字符串引号、缩进等方面的建议。它强调代码的可读性和一致性，并且被广泛视为Python开发中的最佳实践。<br>
以下是主要的规则：<br>
缩进：使用四个空格作为缩进，不要使用制表符。</p>
<p>行长：每行代码不超过 79 个字符。</p>
<p>函数和类命名：使用小写字母和下划线分隔单词的方式来命名函数和类，例如 my_function、my_class。</p>
<p>变量命名：同样使用小写字母和下划线分隔单词的方式来命名变量，例如 my_variable。</p>
<p>空格：在运算符前后加上一个空格，但是在括号内部不加空格。</p>
<p>注释：使用注释来解释代码的意图，注释应该清晰、简洁、易于理解。</p>
<p>导入格式：每个导入应该独占一行，并放置在文件开头。标准库模块应该先导入，然后是第三方模块，最后是本地模块。</p>
<p>空行：使用空行分隔函数和类定义以及函数内的逻辑块，但是不要滥用空行。</p>
<h4 id="常用库">常用库</h4>
<h5 id="Numpy">Numpy</h5>
<p>NumPy提供了高效的数组操作和数学函数，这使得它成为数值分析、科学计算和数据科学任务的首选库之一。它支持多维数组，包括向量、矩阵和张量，并且提供了广泛的数学函数和线性代数运算。更适合数值处理的场景。此外，NumPy还具有良好的内存管理和优化，因此在处理大型数据集时非常快速和高效。</p>
<h5 id="Pandas">Pandas</h5>
<p>Pandas是一个基于NumPy构建的库，它提供了更高级别的数据结构，例如Series和DataFrame，这些结构与传统的SQL数据库表非常相似。适合各种类型的异质性数据，使用Pandas，可以轻松地读取、写入、转换和过滤数据，以及执行聚合、重塑和透视等常见操作。Pandas内置了许多强大的函数和方法，可以利用Python的灵活性和易用性来完成复杂的数据处理任务。</p>
<h4 id="virtual-environment">virtual environment</h4>
<p>虚拟环境是隔离的 Python 环境，在其中你可以为特定的项目安装包。这很有用，因为不同的项目可能需要相同包的不同版本，甚至不同版本的 Python 本身。通过使用虚拟环境，你可以避免包之间的冲突，并确保你的项目具有所需的依赖项。</p>
<p><a target="_blank" rel="noopener" href="https://docs.python-guide.org/dev/virtualenvs/">Pipenv</a>是一个用于 Python 项目的虚拟环境和包管理工具。它为你的项目创建并管理虚拟环境，使你可以安装包而不影响系统上全局的 Python 安装。可以通过终端来运行；</p>
<h4 id="Jupyter-Notebooks-Lab">Jupyter Notebooks / Lab</h4>
<p>Jupyter Notebook 和 Jupyter Lab都是基于Web的交互式计算环境，用于创建和贡献文档，其中包括代码、方程式、可视化图标以及文字说明等元素。他们通常运行在本地计算机或远程服务器上，并且都支持多项语言，包括Python、R、Julia 等。</p>
<p>Jupyter Notebook 是最早的 Jupyter 项目，它通过单元格的方式组织代码和文本，并支持即时运行代码并查看输出结果。这些单元格可以随时修改、重新运行，并与其他单元格进行交互。Jupyter Notebook 还支持 Markdown 来添加富文本说明、数学公式和图像等内容。</p>
<p>Jupyter Lab 是 Jupyter Notebook 的下一代版本，增加了许多强大的功能和改进，例如更好的多窗口管理、扩展性和自定义界面。它还支持在同一个界面中同时打开多个文件类型（如 Notebooks、文本文件、终端等）。</p>
<p>总的来说，Jupyter Notebooks 和 Jupyter Lab 非常适合数据分析、科学计算和软件开发等领域，它们使得工作流程更加高效、可重复和易于分享。要在本地使用Jupyter Notebook，您需要安装<a target="_blank" rel="noopener" href="https://www.anaconda.com/products/individual">Anaconda</a>或Miniconda。这些是Python发行版，包括Jupyter Notebook和其他常用数据科学工具。</p>
<p><img src="https://cdn.jsdelivr.net/gh/duckywang/picgo/img/202304110817096.png" alt="Python基础"></p>
<h3 id="Data-Sources">Data Sources</h3>
<h4 id="Data-mining">Data mining</h4>
<p>数据挖掘是关于如何实现（商业）问题/目标的事情，是充分挖掘已知信息，来推测未知信息；通常在一个完整的建模分析中，数据挖掘的时间往往大于所谓的分析时间，数据质量，维度特征的重要性非常高，尤其是在机器学习中，不同特征的选取直接会对模型效果有较大影响；而在深度学习和集成学习中，由于神经网络的结构会天然对特征进行筛选，而机器往往比人类完成的会更好，因此很多场景中神经网络模型要比机器学习出色很多，这也说明了数据挖掘的重要性；</p>
<h4 id="Web-Scraping">Web Scraping</h4>
<p>爬虫：网页数据检索/抓取</p>
<p>爬虫好处：<br>
· 能够批量且及时的更新你所关注的信息，听上去也是一种非常geek的信息获取方式，这种信息输入模型或直接提取能够发挥较大的实用价值；<br>
爬虫劣势：<br>
· 爬虫语言本身是一种相对静态获取信息的方式，因此随着要爬取对象包含JavaScript代码的多少(当网页中大量使用JavaScript时，这些JavaScript代码可以对爬虫产生很大的影响，包括页面中的内容发生改变、URL的生成发生变化、内容的异步加载等，这都可能导致爬虫难以成功地提取所需的数据)，难度会不断上升，通常需要更为复杂的工具，例如Selenium等，以便能够完全模拟浏览器的行为来获取所需的数据；<br>
· 随着AI的发展，AI能够自行检索网络信息，在信息处理领域人工智能的价值越来越大，因此掌握爬虫技术的性价比会越来越低；<br>
· 爬虫需要遵守robots.text君子协议，基本上有用的信息都反爬，所以爬虫往往需要肩负法律风险；<br>
· 因为网页通常是出于不断迭代中的，反爬技术也在不断更新，因此维护一段爬虫代码对精力投入的要求也是比较高的；</p>
<p>小结，爬虫只是一种互联网信息的获取方式，有很多获取信息的方式，需要考虑使用成本和方便程度，重要的是是否能够获取的信息，让信息为你所用；比如下一part，就会展示其实有很多组织和个人在做优质信息的处理和分享工作；如果更好地使用优质低成本的公开信息，也许更有价值；</p>
<h4 id="Awesome-Public-Datasets">Awesome Public Datasets</h4>
<p><a target="_blank" rel="noopener" href="https://github.com/awesomedata/awesome-public-datasets">分类目学科的官方数据目录</a></p>
<h4 id="Kaggle">Kaggle</h4>
<p>Kaggle 上有很多竞赛会提供高质量且真实的数据集供大家使用学习，这里有一些使用tips~</p>
<ol>
<li>在Kaggle平台上可以找到各种主题的数据科学竞赛，包括分类、回归、聚类、自然语言处理、图像识别、时间序列预测等。寻找感兴趣的竞赛，并阅读比赛的描述、数据、评估标准等信息。</li>
<li>在参加比赛之前，需要先了解比赛所提供数据的格式、特点以及数据分布等情况。可以下载并分析数据，挖掘数据背后的信息。</li>
<li>在得到数据之后，可以根据比赛要求和自己的理解，构建和训练本地的机器学习模型，进行组合调参等优化，提高模型的预测表现。</li>
<li>当完成模型训练后，需要将模型提交到Kaggle竞赛平台以进行评估。提交后Kaggle平台将使用测试数据集来评估模型的性能，给出排名和评估指标。但是对于初学者，排名也许不是最重要的，而是理解不同模型方法对模型准确性的影响，不断积累对数据挖掘的模型经验才是最重要的；</li>
<li>参考讨论区：在参加比赛的过程中，可以参考讨论区查看其他用户的解决方案和经验，同时也可以在讨论区提出自己的问题与其他用户交流和讨论。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/duckywang/picgo/img/202304151319022.png" alt="Data Sources"></p>
<h3 id="常见的数据挖掘方法">常见的数据挖掘方法</h3>
<h4 id="PCA-主成分分析">PCA 主成分分析</h4>
<p>PCA是用信息中的主要成分表示原信息的特征，是通过降维进行信息压缩（降维）的一种方式；</p>
<p>原理：首先去中心化，然后旋转遍历找最合适的坐标系向量（找方差最大的方向，数据分布最分散的方向）原数据在正交轴上投影的分布，方差越大，数据越分散，能够保存样本点最多特征信息的最佳坐标系–&gt;压缩后尽可能保留更多的信息量；</p>
<p>度量指标：这里的最佳坐标系可以理解为初始坐标系的线性变化，通常我们用协方差来度量 坐标系信息线性变换每个瞬间的离散程度；协方差表示：矩阵中的变量之间，相关性如何；xy同向变动时协方差较大，xy反方向变动时协方差为负；</p>
<p>迭代：由于协方差在数量大时计算相当复杂，因此在大数据量的情况下我们可以通过SVD直接计算PCA；在线性代数领域优化SVD的算法优化非常多，因此SVD在进行矩阵分解的计算有更优秀的性能；SVD的右奇异矩阵起到的作用同样是对列数即特征维度的压缩，等同于PCA的作用；</p>
<h4 id="Dimensionality-Numerosity-Reduction">Dimensionality &amp; Numerosity Reduction</h4>
<p>数据归约：通过数据维度降维或样本量减少的方式，优化数据分析的一种数据挖掘技术；<br>
常用方法：</p>
<ol>
<li>抽样（Data Sampling）</li>
<li>聚类（Clustering）</li>
<li>汇总（Data Aggregation）</li>
<li>泛化（Data  Generalization）：用通用性的数据替代某些数据，使数据集仍能代表本身的重要信息；</li>
<li>数据压缩（Data Compression）：通常有有损压缩和无损压缩，在图像处理，视频等高维数据中比较多常见；<br>
Pros ：<br>
· 提升学习效率，更快；<br>
· 提成学习性能（准确性，降低干扰）；<br>
· 节省存储成本；<br>
· 降低数据的解释成本（减少低相关的数据）；<br>
Cons ：<br>
· 信息有损<br>
· 影响准确性（当不小心删减了重要信息时）<br>
· 提升数据的解释成本（当删减过多上下文，导致数据语境不明）<br>
· 计算成本：进行数据压缩同样需要大量的机器计算成本</li>
</ol>
<h4 id="归一化-Normalization">归一化 Normalization</h4>
<p>归一化可以尽可能地保留数据内部样本之间的分布关系，而忽略数据绝对值的信息，从而使不同数据集之间的数据有可比性，能够更公允的对齐不同数据间的情况；</p>
<p>常见的操作：</p>
<ol>
<li>
<p>最大-最小规范化（Min-max normalization）：将数据转换到[,1]区间内。公式为：x_norm = (x - min(x)) / (max(x) - min(x))</p>
</li>
<li>
<p>z-score标准化（Z-score normalization）：将数据通过平均数偏移和标准偏差缩放转换到标准正态分布上。公式为：x_norm = (x - mean(x)) / std(x)</p>
</li>
<li>
<p>小数定标规范化（Decimal scaling normalization）：通过缩放因子10的幂次，将数据转换为[-1,1]或[,1]区间内。公式为：x_norm = x / (10 ^ j)，其中j为作为缩放因子的幂次。</p>
</li>
<li>
<p>归一化积分值（Normalization by integral）：将数据划分为若干区间，然后将每个区间的数据值除以整个数据集的总和。公式为：x_norm = x / Sum(x)</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/duckywang/picgo/img/20230415132210.png" alt="Data Exploratory"></p>
<h4 id="数据清洗">数据清洗</h4>
<blockquote>
<p>Quality data beats fancy algorithms.<br>
尤其是在在如今大模型、通用人工智能模型表现出如此智能化/涌现 能力的今天，数据质量的重要性将比以往任何时候都更加重要；<br>
在处理和清洗数据前，搞清楚的明白你的目的，比采取任何行动都至关重要；</p>
</blockquote>
<p>一些CheatSheet：</p>
<ol>
<li>
<p>标准「数据质量」：正确/有用性，准确性，完整性，连续性/一致性，统一性<br>
· 数据可用性：数据格式、数据取值范围、空值检查/补全、数据去重、枚举值梳理、外键约束（一个表的外键必须存在于另一个表的主键）交叉验证；<br>
· 数据格式化处理<br>
· 数据有用性校验（end_date&gt;start_date）<br>
· 量纲统一</p>
</li>
<li>
<p>ToDo「工作流」：数据检查、数据清洗、数据可用性处理、数据报告<br>
· 数据检查： 整体探查，可视化<br>
· 数据清洗：不相关数据删除，重复数据合并，数据类型转换，格式纠正（eg：移除不必要的空格），标准化、量纲/范围修正（极端值剔除），归一化，空值处理（丢弃、推断补充、相似移植，标识（0/missing），数据逻辑校验（如果指标间有计算关系可以校验）</p>
</li>
</ol>
<blockquote>
<p>关于标识 Flag的处理方法的适用场景，可以参考幸存者偏差，因为很可能空值的样本本在总体中的分布式有原因的而非随机，那这种情况空值本身也是一种特征（删除和推断都会让我们丢失信息），如果被填充或者删除都会影响学习效果；<br>
·记录在数据清洗中的主要工作，帮助我们在需要时进行回溯或迭代；</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://duckywang.github.io">Ducky</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://duckywang.github.io/2023/02/01/%E6%95%B0%E6%8D%AE%E5%BA%94%E7%94%A8%E5%AD%A6%E4%B9%A0roadmap/">https://duckywang.github.io/2023/02/01/%E6%95%B0%E6%8D%AE%E5%BA%94%E7%94%A8%E5%AD%A6%E4%B9%A0roadmap/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://duckywang.github.io" target="_blank">Ducky's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE/">数据</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/duckywang/picgo/img/202304111339462.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2023/04/24/%E6%B8%B8%E6%88%8F%E4%B8%8E%E5%B7%A5%E4%BD%9C/" title="随笔-游戏与工作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">随笔-游戏与工作</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/blog-folder%5Csource%5Cimg%5Cwallhaven-404!.jpeg'" alt="avatar"/></div><div class="author-info__name">Ducky</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/duckywang" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:wky0112@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">导言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Foundamentals"><span class="toc-number">2.</span> <span class="toc-text">Foundamentals</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E5%92%8C%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80"><span class="toc-number">2.1.</span> <span class="toc-text">矩阵和线性代数基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80"><span class="toc-number">2.2.</span> <span class="toc-text">数据库基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E5%9E%8B%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%EF%BC%9A"><span class="toc-number">2.2.1.</span> <span class="toc-text">关系型和非关系型数据：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9A%84SQL%E8%AF%AD%E6%B3%95"><span class="toc-number">2.2.2.</span> <span class="toc-text">基础的SQL语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NoSQL"><span class="toc-number">2.2.3.</span> <span class="toc-text">NoSQL</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E6%A0%BC%E6%95%B0%E6%8D%AE%EF%BC%9A"><span class="toc-number">2.3.</span> <span class="toc-text">表格数据：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DataFrame-Series"><span class="toc-number">2.4.</span> <span class="toc-text">DataFrame &amp; Series</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%A2%84%E5%8A%A0%E5%B7%A5ETL"><span class="toc-number">2.5.</span> <span class="toc-text">数据预加工ETL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reporting-BI-Analytics"><span class="toc-number">2.6.</span> <span class="toc-text">Reporting &amp; BI &amp; Analytics</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Data-Formats-%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.7.</span> <span class="toc-text">Data Formats 常见的数据交换格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JSON"><span class="toc-number">2.7.1.</span> <span class="toc-text">JSON</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XML"><span class="toc-number">2.7.2.</span> <span class="toc-text">XML</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSV"><span class="toc-number">2.7.3.</span> <span class="toc-text">CSV</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8FRegExp"><span class="toc-number">2.8.</span> <span class="toc-text">正则表达式RegExp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python-Programming"><span class="toc-number">2.9.</span> <span class="toc-text">Python Programming</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Python-%E5%9F%BA%E7%A1%80"><span class="toc-number">2.9.1.</span> <span class="toc-text">Python 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Python%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.9.1.1.</span> <span class="toc-text">Python表达式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">2.9.1.2.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.9.1.3.</span> <span class="toc-text">数据格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">2.9.1.4.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%85%E7%AE%A1%E7%90%86%E8%AF%AD%E8%A8%80-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">2.9.1.5.</span> <span class="toc-text">包管理语言&amp;依赖管理器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Codestyle"><span class="toc-number">2.9.1.6.</span> <span class="toc-text">Codestyle</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%BA%93"><span class="toc-number">2.9.2.</span> <span class="toc-text">常用库</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Numpy"><span class="toc-number">2.9.2.1.</span> <span class="toc-text">Numpy</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Pandas"><span class="toc-number">2.9.2.2.</span> <span class="toc-text">Pandas</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#virtual-environment"><span class="toc-number">2.9.3.</span> <span class="toc-text">virtual environment</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Jupyter-Notebooks-Lab"><span class="toc-number">2.9.4.</span> <span class="toc-text">Jupyter Notebooks &#x2F; Lab</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Data-Sources"><span class="toc-number">2.10.</span> <span class="toc-text">Data Sources</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Data-mining"><span class="toc-number">2.10.1.</span> <span class="toc-text">Data mining</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Web-Scraping"><span class="toc-number">2.10.2.</span> <span class="toc-text">Web Scraping</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Awesome-Public-Datasets"><span class="toc-number">2.10.3.</span> <span class="toc-text">Awesome Public Datasets</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kaggle"><span class="toc-number">2.10.4.</span> <span class="toc-text">Kaggle</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%96%B9%E6%B3%95"><span class="toc-number">2.11.</span> <span class="toc-text">常见的数据挖掘方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PCA-%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90"><span class="toc-number">2.11.1.</span> <span class="toc-text">PCA 主成分分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dimensionality-Numerosity-Reduction"><span class="toc-number">2.11.2.</span> <span class="toc-text">Dimensionality &amp; Numerosity Reduction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%92%E4%B8%80%E5%8C%96-Normalization"><span class="toc-number">2.11.3.</span> <span class="toc-text">归一化 Normalization</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97"><span class="toc-number">2.11.4.</span> <span class="toc-text">数据清洗</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/13/%E9%9A%8F%E7%AC%94-%E5%AE%97%E6%95%99%E4%B8%8E%E7%A7%91%E5%AD%A6/" title="随笔-宗教与科学">随笔-宗教与科学</a><time datetime="2023-08-12T16:00:00.000Z" title="发表于 2023-08-13 00:00:00">2023-08-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/13/%E9%9A%8F%E7%AC%94-%E8%84%91%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%8F%E8%A7%82%E6%84%9F%E7%9F%A5/" title="脑结构的宏观感知随笔">脑结构的宏观感知随笔</a><time datetime="2023-08-12T16:00:00.000Z" title="发表于 2023-08-13 00:00:00">2023-08-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/26/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3BP%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BB%8E%E9%94%99%E8%AF%AF%E4%B8%AD%E5%AD%A6%E4%B9%A0%EF%BC%8C%E5%9C%A8%E4%BC%A0%E9%80%92%E4%B8%AD%E8%BF%9B%E5%8C%96(%E4%BA%8C)/" title="如何理解BP算法：从错误中学习，在传递中进化(二)">如何理解BP算法：从错误中学习，在传递中进化(二)</a><time datetime="2023-07-25T16:00:00.000Z" title="发表于 2023-07-26 00:00:00">2023-07-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/23/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3BP%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BB%8E%E9%94%99%E8%AF%AF%E4%B8%AD%E5%AD%A6%E4%B9%A0%EF%BC%8C%E5%9C%A8%E4%BC%A0%E9%80%92%E4%B8%AD%E8%BF%9B%E5%8C%96(%E4%B8%80)/" title="如何理解BP算法：从错误中学习，在传递中进化(一)">如何理解BP算法：从错误中学习，在传递中进化(一)</a><time datetime="2023-07-22T16:00:00.000Z" title="发表于 2023-07-23 00:00:00">2023-07-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/06/23/%E5%9F%BA%E7%A1%80%E7%9A%84%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E2%80%94%E4%BB%8E%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA%E5%BC%80%E5%A7%8B/" title="基础的深度神经网络—从多层感知机开始">基础的深度神经网络—从多层感知机开始</a><time datetime="2023-06-22T16:00:00.000Z" title="发表于 2023-06-23 00:00:00">2023-06-23</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/duckywang/picgo/img/202304111339462.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Ducky</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>